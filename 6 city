import heapq
import networkx as nx
import matplotlib.pyplot as plt

def dijkstra(adj, src):
    dist = {v: float('inf') for v in adj}
    prev = {v: None for v in adj}
    dist[src] = 0
    pq = [(0, src)]
    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]:
            continue
        for v, w in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                prev[v] = u
                heapq.heappush(pq, (nd, v))
    return dist, prev

def reconstruct_path(prev, target):
    if prev[target] is None:
        return [target]
    path = []
    cur = target
    while cur is not None:
        path.append(cur)
        cur = prev[cur]
    return path[::-1]

landmarks = [
    "Town Hall", "Museum", "Park", "Train Station", "Market", "Cathedral", "Library"
]

adj = {
    "Town Hall":     [("Museum", 2), ("Park", 5), ("Market", 3)],
    "Museum":        [("Town Hall", 2), ("Park", 4), ("Library", 6)],
    "Park":          [("Town Hall", 5), ("Museum", 4), ("Train Station", 7)],
    "Train Station": [("Park", 7), ("Market", 6), ("Cathedral", 5)],
    "Market":        [("Town Hall", 3), ("Train Station", 6), ("Cathedral", 4)],
    "Cathedral":     [("Market", 4), ("Train Station", 5), ("Library", 8)],
    "Library":       [("Museum", 6), ("Cathedral", 8)]
}

source = "Town Hall"
dist, prev = dijkstra(adj, source)

print(f"Shortest distances from '{source}':")
for v in sorted(dist.keys()):
    d = dist[v]
    print(f"  {v:14s} : {d if d != float('inf') else 'âˆž'}")

print("\nShortest paths from source:")
for v in landmarks:
    if v == source:
        print(f"  {v} : {source}")
        continue
    path = reconstruct_path(prev, v)
    if dist[v] == float('inf'):
        print(f"  {v} : no path")
    else:
        print(f"  {v} : {' -> '.join(path)} (cost {dist[v]})")

G = nx.Graph()
for u in adj:
    G.add_node(u)
for u, nbrs in adj.items():
    for v, w in nbrs:
        if not G.has_edge(u, v):
            G.add_edge(u, v, weight=w)

pos = nx.spring_layout(G, seed=42)
edge_labels = nx.get_edge_attributes(G, 'weight')

tree_edges = set()
for v in G.nodes():
    p = prev[v]
    if p:
        e = tuple(sorted((p, v)))
        tree_edges.add(e)

edge_colors = []
for u, v in G.edges():
    e = tuple(sorted((u, v)))
    edge_colors.append('red' if e in tree_edges else 'lightgray')

node_colors = []
for n in G.nodes():
    if n == source:
        node_colors.append('gold')
    else:
        node_colors.append('skyblue')

plt.figure(figsize=(10, 7))
nx.draw_networkx_nodes(G, pos, node_size=1000, node_color=node_colors)
nx.draw_networkx_labels(G, pos, font_size=9, font_weight='bold')
nx.draw_networkx_edges(G, pos, width=2, edge_color=edge_colors)
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
plt.title(f"City Landmarks and Shortest-path Tree from '{source}'")
plt.axis('off')
plt.show()
