#include <iostream>
using namespace std;
#define V 5 // Change V according to your number of cities (nodes)
bool isSafe(int v, bool graph[V][V], int path[], int pos) {
// Check if this vertex is adjacent to the previously added vertex
if (graph[path[pos - 1]][v] == 0)
return false;
// Check if the vertex has already been included in the path
for (int i = 0; i < pos; i++)
if (path[i] == v)
return false;
return true;
}
bool hamCycleUtil(bool graph[V][V], int path[], int pos) {
// base case: if all vertices are included in the cycle
if (pos == V) {
// And if there is an edge from the last included vertex to the first vertex
if (graph[path[pos - 1]][path[0]] == 1)
return true;
else
return false;
}
//Trydifferentverticesasnextcandidates in Hamiltonian Cycle
for (int v = 1; v < V; v++) {
if (isSafe(v, graph, path, pos)) {
path[pos] = v;
if(hamCycleUtil(graph,path,pos + 1) == true)
return true;
//Ifaddingvdoesn'tleadtoasolution, remove it (backtrack)
path[pos] = -1;
}
}
return false;
}
void printSolution(int path[]) {
cout<<"HamiltonianCycleexists:";
for (int i = 0; i < V; i++)
cout << path[i] << " ";
cout<<path[0]<<endl;//showcycle return to start
}
bool hamCycle(bool graph[V][V]) {
int *path = new int[V];
for (int i = 0; i < V; i++)
path[i] = -1;
path[0] = 0;
if(hamCycleUtil(graph,path,1)==false) {
cout<<"HamiltonianCycledoesnot exist" << endl;
return false;
}
printSolution(path);
return true;
}
int main() {
// Example adjacency matrix for 5 cities
bool graph1[V][V] = {
{0, 1, 0, 1, 0},
{1, 0, 1, 1, 1},
{0, 1, 0, 0, 1},
{1, 1, 0, 0, 1},
{0, 1, 1, 1, 0}
};
hamCycle(graph1);
bool graph2[V][V] = {
{0, 1, 0, 1, 0},
{1, 0, 1, 1, 1},
{0, 1, 0, 0, 1},
{1, 1, 0, 0, 0},
{0, 1, 1, 0, 0}
};
hamCycle(graph2);
return 0;
}
